//@version=6
indicator("MTF-entry", overlay=true)

//------------------------ MODUL: CORE STATE MACHINE LOGIC (Inline Persistence) {
// This function now contains the state persistence logic using 'var' variables, 
// running on the current chart's timeframe.
f_current_timeframe_state() =>
    // 'var' variables persist their value across bars
    var int _state = 0 // 1:UP, -1:DOWN, 0:NEUTRAL/Initial
    var float _price = na // Price at which the flip occurred
    var bool _flipped = false // True if state just flipped

    // Define the conditions for a "flip"
    candle_up   = close > high[1] // Current close is higher than the previous high
    candle_down = close < low[1]  // Current close is lower than the previous low

    _flipped := false // Reset flip status on every bar

    if candle_up and (_state == -1 or _state == 0)
        _state := 1
        _price := close
        _flipped := true
    else if candle_down and (_state == 1 or _state == 0)
        _state := -1
        _price := close
        _flipped := true
    
    // Return the current state, price, and flip status
    [_state, _price, _flipped]
//}


//------------------------ MODUL: RUN LOGIC FOR CURRENT TIMEFRAME {
// Run the core logic function directly on the current chart's timeframe
[state_ctf, price_ctf, flipped_ctf] = f_current_timeframe_state()
//}

//------------------------ MODUL: BAR COLORING {
get_color(state) =>
    state == 1 ? color.new(color.white, 0) : state == -1 ? color.new(color.gray, 0) : na

// Color the bar based on the current timeframe state
barcolor(get_color(state_ctf))
//}

//------------------------ MODUL: ALERTS {

get_previoius_lowest_point() =>
    _prevBeCycle = ta.barssince(flipped_ctf and state_ctf == -1)
    _prevBeCycleLowestPoint = ta.lowest(low, _prevBeCycle > 0 ? _prevBeCycle : 1)
    [_prevBeCycle, _prevBeCycleLowestPoint]

[prevBearishCycle, prevBearishCycleLowestPoint] = get_previoius_lowest_point()

// Persist the previous previous lowest point for comparison
var float previousPrevBearishCycleLowestPoint = na
longPositionConfirmed = flipped_ctf and state_ctf == 1
ctf_name = timeframe.period

// 🐛 FIXED BUG HERE: alertcondition titles must be const strings.
// We use generic, fixed titles here.
//alertcondition(flipped_ctf and state_ctf == 1, title="Entry - Long alert",   message="Entry - Long confirmed")
//alertcondition(flipped_ctf and state_ctf == -1, title="Entry - Short alert", message="Entry - Short confirmed")

// Label and alert for Long entry
if longPositionConfirmed
    // Determine label color based on whether the new lowest point is higher than the previous one
    //_lblColor = prevBearishCycleLowestPoint > previousPrevBearishCycleLowestPoint ? color.white : color.new(color.white, 90)
    //label.new(bar_index, high, text = na, style=label.style_label_up, yloc=yloc.belowbar, color=_lblColor, textcolor=color.black, size=size.tiny)
    
    // Only alert if the new lowest point is higher than the previous one
    if prevBearishCycleLowestPoint > previousPrevBearishCycleLowestPoint
        label.new(bar_index, high, text = na, style=label.style_label_up, yloc=yloc.belowbar, color=color.white, textcolor=color.black, size=size.tiny)
        alert_msg = syminfo.ticker + " " + ctf_name + " " + (state_ctf == 1 ? "UP" : "DOWN") + " @ " + str.tostring(price_ctf, "#.#####")
        alert(alert_msg, alert.freq_once_per_bar_close)
    // Update the previous lowest point after processing
    previousPrevBearishCycleLowestPoint := prevBearishCycleLowestPoint
    
//}