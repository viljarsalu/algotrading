//@version=6
indicator("MTF-setup", overlay=true)

//------------------------ MODUL: MTF STATE MACHINE LOGIC (Inline Persistence)  {
// This function contains the state persistence logic using 'var' variables, 
// which are correctly isolated within the request.security context.
f_mtf_state() =>
    var int _state = 0
    var float _price = na
    var bool _flipped = false
    var int _counter = 0
    
    candle_up   = close > high[1]
    candle_down = close < low[1]

    _flipped := false // Reset flip status on every bar

    if candle_up and (_state == -1 or _state == 0)
        _state := 1
        _price := close
        _flipped := true
    else if candle_down and (_state == 1 or _state == 0)
        _state := -1
        _price := close
        _flipped := true
    // Counter logic
    if _flipped
        _counter := 0
    else if _state == 1 or _state == -1
        _counter += 1
    
    // Return the current state, price, and flip status for the secondary bar
    [_state, _price, _flipped, _counter]
//}


//------------------------ MODUL: RUN LOGIC FOR 1H, 4H, AND 1D (FIXED: using barmerge.gaps_off)  {
// Changing lookahead to gaps_off ensures we only use the last *confirmed* state,
// which is required for non-repainting historical accuracy, especially on tables.

[state_1h, price_1h, flipped_1h, count_1h] = request.security(syminfo.tickerid, "60", f_mtf_state(), barmerge.gaps_off)
[state_4h, price_4h, flipped_4h, count_4h] = request.security(syminfo.tickerid, "240", f_mtf_state(), barmerge.gaps_off)
[state_1d, price_1d, flipped_1d, count_1d] = request.security(syminfo.tickerid, "1D", f_mtf_state(), barmerge.gaps_off)
//}


//------------------------ MODUL: BAR COLORING  {
is_1h_chart = (timeframe.period == "60" or timeframe.period == "1H")
is_4h_chart = (timeframe.period == "240" or timeframe.period == "4H")
is_1d_chart = (timeframe.period == "1D" or timeframe.period == "D")

get_color(state) =>
    state == 1 ? color.new(color.white, 0) : state == -1 ? color.new(color.gray, 0) : na

barcolor(is_1h_chart ? get_color(state_1h) :is_4h_chart ? get_color(state_4h) :is_1d_chart ? get_color(state_1d) :na)
//}

//------------------------ MODUL: ALERTS  {
// static alerts (for TradingView rule setup)
alertcondition(flipped_1h and state_1h == 1, title="Setup - 1H UP",   message="Setup - 1H UP confirmed")
alertcondition(flipped_1h and state_1h == -1, title="Setup - 1H DOWN", message="Setup - 1H DOWN confirmed")
alertcondition(flipped_4h and state_4h == 1, title="Setup - 4H UP",   message="Setup - 4H UP confirmed")
alertcondition(flipped_4h and state_4h == -1, title="Setup - 4H DOWN", message="Setup - 4H DOWN confirmed")
alertcondition(flipped_1d and state_1d == 1, title="Setup - 1D UP",   message="Setup - 1D UP confirmed")
alertcondition(flipped_1d and state_1d == -1, title="Setup - 1D DOWN", message="Setup - 1D DOWN confirmed")

// runtime alerts with price info
//if flipped_1h
//    alert_msg = syminfo.ticker + " 1H " + (state_1h == 1 ? "UP" : "DOWN") + " @ " + str.tostring(price_1h, "#.#####")
//    alert(alert_msg, alert.freq_once_per_bar_close)
//if flipped_4h
//    alert_msg = syminfo.ticker + " 4H " + (state_4h == 1 ? "UP" : "DOWN") + " @ " + str.tostring(price_4h, "#.#####")
//    alert(alert_msg, alert.freq_once_per_bar_close)
//if flipped_1d
//    alert_msg = syminfo.ticker + " 1D " + (state_1d == 1 ? "UP" : "DOWN") + " @ " + str.tostring(price_1d, "#.#####")
//    alert(alert_msg, alert.freq_once_per_bar_close)

//}


//------------------------ MODUL: TABLE (Bottom-Right) {
var table t = table.new(position.bottom_right, 3, 2, border_width=1)

// header row (once)
if barstate.isfirst
    table.cell(t, 0, 0, "1h", text_color=color.white, bgcolor=color.black)
    table.cell(t, 1, 0, "4h", text_color=color.white, bgcolor=color.black)
    table.cell(t, 2, 0, "1d", text_color=color.white, bgcolor=color.black)

// helper function for table updates
f_update_cell(col, state, price, count) =>
    // UPDATED: Removed price information, leaving only the state text.
    txt = switch state
        1 => "UP" +" (" + str.tostring(count) + ")"
        -1 => "DOWN" +" (" + str.tostring(count) + ")"
        => "NEUTRAL"
    
    bg = switch state
        1 => color.new(color.green, 0)
        -1 => color.new(color.red, 0)
        => color.new(color.gray, 80)
        
    table.cell(t, col, 1, txt, text_color=color.white, bgcolor=bg)

// update each timeframe cell 
f_update_cell(0, state_1h, price_1h, count_1h)
f_update_cell(1, state_4h, price_4h, count_4h)
f_update_cell(2, state_1d, price_1d, count_1d)
//}